{"version":3,"sources":["../../fable-arch/src/Fable.Arch/Fable.Arch.App.fs"],"names":[],"mappings":"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","file":"Fable.Arch.App.js","sourcesContent":["module Fable.Arch.App\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen System.Diagnostics\n\nopen Html\n\n[<AutoOpen>]\nmodule Types =\n    type Handler<'TMessage> = 'TMessage -> unit\n\n    type ModelChanged<'TMessage, 'TModel> =\n        {\n            PreviousState: 'TModel\n            Message: 'TMessage\n            CurrentState: 'TModel\n        }\n\n    type AppEvent<'TMessage, 'TModel> =\n        | ModelChanged of ModelChanged<'TMessage, 'TModel>\n        | ActionReceived of 'TMessage\n        | Replayed of (System.Guid * 'TModel) list\n\n    type AppMessage<'TMessage, 'TModel> =\n        | Message of 'TMessage\n        | Replay of 'TModel*((System.Guid*'TMessage) list)\n\n    type Action<'TMessage> = Handler<'TMessage> -> unit\n\n    type Subscriber<'TMessage, 'TModel> = AppEvent<'TMessage, 'TModel> -> unit\n    type Producer<'TMessage, 'TModel> = Action<AppMessage<'TMessage, 'TModel>>\n    type Plugin<'TMessage, 'TModel> =\n        {\n            Producer: Producer<'TMessage, 'TModel>\n            Subscriber: Subscriber<'TMessage, 'TModel>\n        }\n\n    type Selector = string\n\n    type AppSpecification<'TModel, 'TMessage, 'TView> =\n        {\n            InitState: 'TModel\n            View: 'TModel -> 'TView\n            Update: 'TModel -> 'TMessage -> ('TModel * Action<'TMessage> list)\n            InitMessage: Action<'TMessage>\n            CreateRenderer: Selector -> Handler<'TMessage> -> 'TView -> (Handler<'TMessage> -> 'TView -> unit)\n            NodeSelector: Selector\n            Producers: Producer<'TMessage, 'TModel> list\n            Subscribers: Subscriber<'TMessage, 'TModel> list\n        }\n\n    type App<'TModel, 'TMessage, 'TView> =\n        {\n            Model: 'TModel\n            Actions: (unit -> unit) list\n            Render: Handler<'TMessage> -> 'TView -> unit\n            Subscribers: Subscriber<'TMessage, 'TModel> list\n        }\n\n    let application<'TMessage, 'TModel, 'TView> initMessage handleMessage handleReplay configureProducers createInitApp =\n        let mutable state = None\n\n        let notifySubs msg =\n            match state with\n            | Some s ->\n                s.Subscribers |> List.iter (fun sub -> sub msg)\n            | None -> ()\n\n        let rec handleEvent (evt:AppMessage<'TMessage, 'TModel>) =\n            let (state', actions)  : App<'TModel, 'TMessage, 'TView>*(unit -> unit) list =\n                match evt with\n                | Message message ->\n                    handleMessage handleEvent notifySubs message (state |> Option.get)\n                | Replay (model, messages) ->\n                    handleReplay handleEvent notifySubs (model, messages) (state |> Option.get)\n            state <- Some state'\n            actions |> List.iter (fun x -> x())\n\n        let post = (Message >> handleEvent)\n        state <- createInitApp post |> Some\n        initMessage post\n\n        configureProducers handleEvent\n        handleEvent\n\n    let render post viewFn app =\n        let view = viewFn app.Model\n        app.Render (Message >> post) view\n        app\n\n    let createActions post = List.map (fun a -> fun () -> a (Message >> post))\n\n    let handleMessage update viewFn post notifySubs message app =\n        notifySubs (ActionReceived message)\n        let (model, actions) = update app.Model message\n\n        let modelChanged =\n            ModelChanged {\n                CurrentState = model\n                PreviousState = app.Model\n                Message = message\n            }\n\n        let actions = createActions post actions\n        let app' =\n            {app with Model = model}\n            |> render post viewFn\n\n        app', (fun () -> (notifySubs modelChanged))::actions\n\n    let calculateModelChanges initState update actions =\n        let execUpdate r a =\n            let m =\n                match r with\n                | [] -> initState\n                | x::_ -> x |> snd\n            let msg = a |> snd\n            let (m', _) = update m (a |> snd)\n            let id:System.Guid = a |> fst\n            id,m'\n\n        actions\n        |> List.fold (fun s a -> (execUpdate s a)::s) []\n\n    let handleReplay viewFn updateFn post notifySubs (fromModel, actions) app =\n        let result = calculateModelChanges fromModel updateFn actions\n        let model =\n            match result with\n            | m::_ -> m |> snd\n            | [] -> fromModel\n        let app' =\n            {app with Model = model}\n            |> render post viewFn\n\n        app', [fun () -> (Replayed result) |> notifySubs]\n\n[<AutoOpen>]\nmodule AppApi =\n    // Helper functions to map from one action type to another\n    let mapAction<'T1,'T2> (mapping:'T1 -> 'T2) (action:Action<'T1>) : Action<'T2> =\n        fun x -> action (mapping >> x)\n\n    let mapAppMessage map = function\n        | AppMessage.Message msg -> AppMessage.Message (map msg)\n        | Replay (x,messageList) -> Replay (x,messageList |> List.map (fun (id, m) -> id, map m))\n\n    let mapProducer map p = mapAction map p\n\n    let mapSubscriber mapModelChanged mapAction sub = function\n        | ModelChanged mc ->\n            mc |> mapModelChanged |> Option.map ModelChanged |> Option.iter sub\n        | ActionReceived m -> mapAction id m |> Option.map ActionReceived |> Option.iter sub\n        | Replayed lst -> sub (Replayed lst)\n\n    let mapActions m = List.map (mapAction m)\n    let toActionList a = [a]\n\n    // Starting point for creating an application\n    let createApp state view update createRenderer =\n        {\n            InitState = state\n            View = view\n            Update = update\n            InitMessage = (fun _ -> ())\n            CreateRenderer = createRenderer\n            NodeSelector = \"body\"\n            Producers = []\n            Subscribers = []\n        }\n\n    // Starting point for an application with a simpler update function\n    let createSimpleApp model view update =\n        createApp model view (fun x y -> (update x y), [])\n\n    // Fluent api functions to add optional configurations to the application\n    let withStartNodeSelector selector app = { app with NodeSelector = selector }\n    let withInitMessage msg app = { app with InitMessage = msg }\n\n    let private withInstrumentationProducer p app =\n        {app with Producers = p::app.Producers}\n    let withProducer (producer:('a->unit)->unit) app =\n        let lift h = Message >> h\n        let producer' = lift >> producer\n        withInstrumentationProducer producer' app\n\n    let withInstrumentationSubscriber subscriber app =\n        {app with AppSpecification.Subscribers = subscriber::app.Subscribers}\n    let withSubscriber (subscriber:ModelChanged<'a,'b> -> unit) app =\n        let subscriber' = function\n            | ModelChanged m -> m |> subscriber\n            | _ -> ()\n        withInstrumentationSubscriber subscriber' app\n\n    let withPlugin plugin =\n        (withInstrumentationSubscriber plugin.Subscriber)\n        >> (withInstrumentationProducer plugin.Producer)\n\n    let configureProducers producers post =\n        producers |> List.iter (fun p -> p post)\n\n    // Start the application\n    let start (appSpec:AppSpecification<'TModel, 'TMessage, 'TView>) =\n        let viewFn : ('TModel -> 'TView) = appSpec.View\n        let updateFn = appSpec.Update\n\n        let createInitApp post =\n            let view : 'TView = viewFn appSpec.InitState\n            let render = appSpec.CreateRenderer appSpec.NodeSelector post view\n            {\n                Model = appSpec.InitState\n                Render = render\n                Subscribers = appSpec.Subscribers\n                Actions = []\n            } : App<'TModel, 'TMessage, 'TView>\n        let handleMessage' = handleMessage updateFn viewFn\n        let handleReplay' = handleReplay viewFn updateFn\n        let configureProducers' = configureProducers appSpec.Producers\n        application appSpec.InitMessage handleMessage' handleReplay' configureProducers' createInitApp"]}