{"version":3,"sources":["../../fable-arch/src/Fable.Arch/Fable.Arch.RouteParser.fs"],"names":[],"mappings":"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","file":"Fable.Arch.RouteParser.js","sourcesContent":["namespace Fable.Arch.RouteParser \n(*\nBased on the excellent blog series by Scott Wlaschin: http://fsharpforfunandprofit.com/posts/understanding-parser-combinators/\nInspired by Elm Route Parser: http://package.elm-lang.org/packages/etaque/elm-route-parser/2.2.1/\n\n*)\n\n[<AutoOpen>]\nmodule Parsing =\n\n    open System\n    type ParserLabel = string\n    type ParserError = string\n    type Result<'a,'b> =\n        | Success of 'a\n        | Failure of 'b \n\n    type Parser<'a> = {\n        parseFn : (string -> Result<'a * string, ParserLabel*ParserError>)\n        label:  ParserLabel \n        }\n\n    let printResult result =\n        match result with\n        | Success (value,input) -> \n            printfn \"%A\" value\n        | Failure (label,error) -> \n            printfn \"Error parsing %s\\n%s\" label error\n\n    let satisfy predicate label =\n        let innerFn input =\n            if String.IsNullOrEmpty(input) then\n                Failure (label,\"No more input\")\n            else\n                let first = input.[0] \n                if predicate first then\n                    let remainingInput = input.Substring(1)\n                    Success (first,remainingInput)\n                else\n                    let err = sprintf \"Unexpected '%c'\" first\n                    Failure (label,err)\n        {parseFn=innerFn;label=label}\n\n    let pchar charToMatch = \n        let predicate ch = (ch = charToMatch) \n        let label = sprintf \"%c\" charToMatch \n        satisfy predicate label \n\n    let digitChar = \n        let predicate = fun c -> ['0' .. '9'] |> List.contains c \n        let label = \"digit\"\n        satisfy predicate label \n\n    let run parser input = \n        let innerFn = parser.parseFn \n        innerFn input\n\n    let getLabel parser = \n        parser.label\n\n    let setLabel parser newLabel = \n        let newInnerFn input = \n            let result = parser.parseFn input\n            match result with\n            | Success s ->\n                Success s \n            | Failure (oldLabel,err) -> \n                Failure (newLabel,err)\n        {parseFn=newInnerFn; label=newLabel} \n\n    let ( <?> ) = setLabel\n\n    let bindP f p =\n        let label = \"unknown\" \n        let innerFn input =\n            let result1 = run p input \n            match result1 with\n            | Failure (label,err) -> \n                Failure (label,err)  \n            | Success (value1,remainingInput) ->\n                let p2 = f value1\n                run p2 remainingInput\n        {parseFn=innerFn; label=label}\n\n    let ( >>= ) p f = bindP f p\n\n    let returnP x = \n        let label = sprintf \"%A\" x\n        let innerFn input =\n            Success (x,input)\n        {parseFn=innerFn; label=label}\n\n    let mapP f = \n        bindP (f >> returnP)\n\n    let ( <!> ) = mapP\n\n    let ( |>> ) x f = mapP f x\n\n    let applyP fP xP =         \n        fP >>= (fun f -> \n        xP >>= (fun x -> \n            returnP (f x) ))\n\n    let ( <*> ) = applyP\n\n    let lift2 f xP yP =\n        returnP f <*> xP <*> yP\n\n    let andThen p1 p2 =         \n        let label = sprintf \"%s andThen %s\" (getLabel p1) (getLabel p2)\n        p1 >>= (fun p1Result -> \n        p2 >>= (fun p2Result -> \n            returnP (p1Result,p2Result) ))\n        <?> label\n\n    let ( .>>. ) = andThen\n\n    let orElse parser1 parser2 =\n        let label = sprintf \"%s orElse %s\" (getLabel parser1) (getLabel parser2)\n\n        let innerFn input =\n            let result1 = run parser1 input\n\n            match result1 with\n            | Success result -> \n                result1\n            | Failure (_,err) -> \n                let result2 = run parser2 input\n                match result2 with\n                | Success _ -> \n                    result2\n                | Failure (_,err) -> \n                    Failure (label,err)\n        {parseFn=innerFn; label=label}\n\n    let ( <|> ) = orElse\n\n    let choice listOfParsers = \n        List.reduce ( <|> ) listOfParsers \n\n    let anyOf listOfChars = \n        let label = sprintf \"any of %A\" listOfChars \n        listOfChars\n        |> List.map pchar\n        |> choice\n        <?> label\n\n    let zeroOrOne parser = \n        let innerFn input = \n            if input = \"\" then Success(\"\", \"\")\n            else\n                run parser input\n        {parseFn=innerFn; label=\"zeroOrOne\"}\n\n    let rec parseZeroOrMore parser input =\n        let firstResult = run parser input \n        match firstResult with\n        | Failure (_,_) -> \n            ([],input)  \n        | Success (firstValue,inputAfterFirstParse) -> \n            let (subsequentValues,remainingInput) = \n                parseZeroOrMore parser inputAfterFirstParse\n            let values = firstValue::subsequentValues\n            (values,remainingInput)  \n\n    let parseXTimes count parser = \n        let innerFn input = \n            let rec innerParse count' input' acc = \n                if count' = 0 \n                then Success ((acc |> List.rev),input')\n                else \n                    match run parser input' with\n                    | Failure (label,error) -> \n                        let label = sprintf \"Failed to parse \\\"%s\\\" %i number of times \" label count\n                        Failure (label,error)\n                    | Success (v, rest) ->\n                        innerParse (count' - 1) rest (v::acc)\n            innerParse count input []\n        let label = sprintf \"Failed to parse \\\"%s\\\" %i number of times \" (getLabel parser) count\n        {parseFn=innerFn; label=label}\n\n    let many parser = \n        let label = sprintf \"many %s\" (getLabel parser)\n        let rec innerFn input =\n            Success (parseZeroOrMore parser input)\n        {parseFn=innerFn; label=label}\n\n    let many1 p =         \n        let label = sprintf \"many1 %s\" (getLabel p)\n\n        p      >>= (fun head -> \n        many p >>= (fun tail -> \n            returnP (head::tail) ))\n        <?> label\n\n    let (.>>) p1 p2 = \n        p1 .>>. p2 \n        |> mapP (fun (a,b) -> a) \n\n    let (>>.) p1 p2 = \n        p1 .>>. p2 \n        |> mapP (fun (a,b) -> b) \n\n    let drop p = \n        let innerFn input =\n            match run p input with\n            | Success (_, rest) -> Success ((), rest)\n            | Failure (label, error) -> Failure(label, error)\n        {parseFn=innerFn; label=\"drop\"}\n\n    let opt p = \n        let label = sprintf \"opt %s\" (getLabel p)\n        let some = p |>> Some\n        let none = returnP None\n        (some <|> none) <?> label\n\n    let charListToStr charList =\n        String(List.toArray charList) \n\n    let manyChars cp =\n        many cp\n        |>> charListToStr\n\n    let manyChars1 cp =\n        many1 cp\n        |>> charListToStr\n\n    let pint = \n        let label = \"integer\" \n\n        let resultToInt (sign,digits) = \n            let i = digits |> int\n            match sign with\n            | Some ch -> -i\n            | None -> i\n            \n        let digits = manyChars1 digitChar \n\n        opt (pchar '-') .>>. digits \n        |> mapP resultToInt\n        <?> label\n\n    let pfloat = \n        let label = \"float\" \n\n        let resultToFloat (((sign,digits1),point),digits2) = \n            let fl = sprintf \"%s.%s\" digits1 digits2 |> float\n            match sign with\n            | Some ch -> -fl\n            | None -> fl\n\n        let digits = manyChars1 digitChar \n\n        opt (pchar '-') .>>. digits .>>. pchar '.' .>>. digits\n        |> mapP resultToFloat\n        <?> label\n\n    let rec sequence parserList =\n        let cons head tail = head::tail\n\n        let consP = lift2 cons\n\n        match parserList with\n        | [] -> \n            returnP []\n        | head::tail ->\n            consP head (sequence tail)\n\n    let pStaticStr str = \n        let label = str \n\n        str\n        |> List.ofSeq\n        |> List.map pchar \n        |> sequence\n        |> mapP charListToStr \n        <?> label\n\n    let pString = \n        let label = \"string\"\n        let predicate = fun _ -> true\n        satisfy predicate \"string\"\n        |> many\n        |> mapP charListToStr\n\n    let pStringTo endingChar = \n        let label = sprintf \"string up to char %c\" endingChar\n        let ending = pchar endingChar\n\n        let predicate = fun c -> c <> endingChar\n        let stringParser = \n            satisfy predicate \"string\"\n            |> many\n            |> mapP charListToStr\n        stringParser .>> ending\n\n    let phexdigit = \n        let label = \"hexadecimal\"\n        let hexChars = [['a' .. 'f']; ['A' .. 'F']; [ '0' .. '9']] |> List.concat\n        anyOf hexChars <?> \"Expected valid hex digit\"\n    \n    let pguid = \n        let resultToGuid ((x1,(x2:string list)),x3) = \n            let guidStr = sprintf \"%s-%s-%s-%s-%s\" x1 x2.[0] x2.[1] x2.[2] x3\n            Guid.Parse(guidStr)\n        \n        let parseMiddlePart = pchar '-' >>. (parseXTimes 4 phexdigit) |> mapP charListToStr\n        (parseXTimes 8 phexdigit |> mapP charListToStr) .>>. (parseXTimes 3 parseMiddlePart) .>> pchar '-' .>>. (parseXTimes 12 phexdigit |> mapP charListToStr)\n        |> mapP resultToGuid\n        <?> \"guid\"        \n\n    let (</>) p1 p2 =\n        p1 .>> pchar '/' .>>. p2\n\n    let (<./>) p1 p2 =\n        p1 .>> pchar '/' .>> p2\n\n    let (</.>) p1 p2 =\n        p1 >>. pchar '/' >>. p2\n    \n    let _end parser =\n        let label = \"End of input\"\n        let innerFn input =\n            match run parser input with\n            | Success (x, rest) ->\n                if String.IsNullOrEmpty(rest) \n                then\n                    Success (x, rest)\n                else \n                    Failure (label, sprintf \"Expected rest of input to be empty, got %s\" rest)\n            | Failure (label, err) -> Failure(label, err)\n        {parseFn=innerFn; label=label}\n        \n    let choose routes input = \n        routes\n        |> List.tryPick (fun r -> \n            match r input with\n            | Success x -> Some x\n            | Failure (_,_) -> None )\n\n    let runM map route str = \n        match run route str with\n        | Success ((),_) -> map |> Success\n        | Failure (x,y) -> Failure (x,y) \n\n    let runM1 map route str = \n        match run route str with\n        | Success (x,_) -> map x |> Success\n        | Failure (x,y) -> Failure (x,y) \n\n    let runM2 = runM1\n\n    let runM3 map route str = \n        match run route str with\n        | Success (((x,y),z),_) -> map (x,y,z) |> Success\n        | Failure (x,y) -> Failure (x,y) \n\n    let runM4 map route str = \n        match run route str with\n        | Success ((((x,y),z), v),_) -> map (x,y,z,v) |> Success\n        | Failure (x,y) -> Failure (x,y) \n\n    let runM5 map route str = \n        match run route str with\n        | Success (((((x,y),z),v),w),_) -> map (x,y,z,v,w) |> Success\n        | Failure (x,y) -> Failure (x,y) \n\n    let runM6 map route str = \n        match run route str with\n        | Success ((((((x,y),z),v),w),u),_) -> map (x,y,z,v,w,u) |> Success\n        | Failure (x,y) -> Failure (x,y) \n\nmodule RouteParser = \n    open System\n    open Parsing\n    open Fable.Import.Browser\n    type LocationHandler = \n        {\n            SubscribeToChange: (string -> unit) -> unit\n            PushChange: string -> unit\n        }\n    type Router<'TRoute> =\n        {\n            Parse: string -> 'TRoute option\n            Route: 'TRoute -> string option\n        }\n    let createRouter routes mapRoute =\n        {\n            Parse = choose routes\n            Route = mapRoute\n        } \n\n    let routeProducer locationHandler router handler = \n        let changeHandler str =\n            match router.Parse str with\n            | Some route -> route |> handler\n            | None -> () \n        locationHandler.SubscribeToChange changeHandler\n\n    let routeSubscriber locationHandler router message = \n        message\n        |> router\n        |> function\n            | Some s -> locationHandler.PushChange s\n            | None _ -> ()\n"]}